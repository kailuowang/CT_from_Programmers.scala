```Haskell
p' = p . m
q' = q . m
```
```scala
val p' = p compose m
val q' = q compose m

```
...................

```Haskell
f :: c' -> c
```
```scala
val f : C' => C
```
..................
```Haskell
u :: c -> Lim D
```
```scala
val u :  C => Lim[D]
```
..................
```Haskell
u . f :: c' -> Lim D
```
```scala
u compose f : C' => Lim[D]
```
..................
```Haskell
contramap :: (c' -> c) -> (c -> Lim D) -> (c' -> Lim D)
contramap f u = u . f
```
```scala
def contramap[C, C', D[_]](f: C' => C, u: C => Lim[D]): (C' => Lim[D]) = 
  u compose f
```
..................
```Haskell
f :: c' -> c
```
```scala
val f : C' => C
```
..................
```Haskell
Nat(Δc, D) -> Nat(Δc', D)
```
```scala
(Δc ~> D) => (Δc' ~> D)
```
..................
```Haskell
αa :: Δca -> D a
```
```scala
val αA : ΔcA => D[A]
```
..................
```Haskell
αa :: c -> D a
```
```scala
val αA : C => D[A]
```
..................
```Haskell
βA :: c' -> D A
```
```scala
val βA : C' => D[A]
```
..................
```Haskell
βa = αa . f
```
```scala
val βA = αA compose f 
```
..................
```Haskell
c -> Nat(Δc, D)
```
```scala
C => (Δc ~> D) 
```
..................
```Haskell
f :: a -> b
g :: a -> b
```
```scala
val f : A => B
val g : A => B 
```
..................
```Haskell
p :: c -> a
q :: c -> b
```
```scala
val p : C => A
val q : C => B
```
..................
```Haskell
q = f . p
q = g . p
```
```scala
q == f compose p
q == g compose p
```


..................

inline code below
```Haskell
q = f . p
```
```scala
q = f compose p
```


..................
```Haskell
f . p = g . p
```
```scala
f compose p == g compose p
```


..................
```Haskell
f (x, y) = 2 * y + x
g (x, y) = y - x
```
```scala
def f(x, y) = 2 * y + x
def g(x, y) = y - x
```

..................
```Haskell
p t = (t, (-2) * t)
```
```scala
def p(t) = (t, (-2) * t)
```

..................
```Haskell
f . p' = g . p'
```
```scala
f compose p' == g compose p'
```

..................
```Haskell
p'() = (0, 0)
```
```scala
def p'[U](u: U) = u match {
  case _: Unit => (0, 0) 
} 
```

..................
inline code 
```Haskell
f (0, 0) = g (0, 0)
```
```scala
f(0, 0) == g(0, 0)
```


..................
```Haskell
p' = p . h
```
```scala
val p' = p compose h
```

..................
```Haskell
h () = 0
```
```scala
def h(_,_) = 0
```

..................
```Haskell
f :: a -> b
g :: c -> b
```
```scala
val f : A => B
val g : C => B
```
..................
```Haskell
p :: d -> a
q :: d -> c
r :: d -> b
```
```scala
val p : D => A
val q : D => C
val r : D => B
```



..................
```Haskell
g . q = f . p
```
```scala
g compose q == f compose p
```

..................
```Haskell
f x = 1.23
```
```scala
f(x) == 1.23
```

## skipping the paragraphs about Haskell type inference
..................
```Haskell
newtype ToString a = ToString (a -> String)
instance Contravariant ToString where
    contramap f (ToString g) = ToString (g . f)
```
```scala
class ToString[A](f: A => String) extends AnyVal 

implicit val contravariant: Contravariant[ToString] 
    = new Contravariant[ToString] {
    def contramap[A, B](fa: ToString[A])(f: B => A)
      : ToString[B] = ToString(fa.f compose f)
  }
```
..................
```Haskell
ToString (Either b c) ~ (b -> String, c -> String)
```
```scala
ToString[Either[B, C]] ~ (B => String, C => String)
```
..................
```Haskell
r -> (a, b) ~ (r -> a, r -> b)
```
```scala
R => (A, B) ~ (R => A, R => B)
```






